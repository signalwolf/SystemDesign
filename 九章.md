### 系统设计的评分标准：
1.  可行性： 25%
2.  特定问题解：20%
3.  分析能力：25%
4.  tradeoff: 15%
5.  相关知识：15%

### 程序 = 算法 + 数据结构，系统 = 服务 + 数据存储

### SNAKE方法：
1.  Scenario: 明白你要设计什么，将它细分到小的功能模块上
    1.  列举所有的需要的功能：Enumerate the function module needed to have the service
    2.  选出核心的功能：Isolate the core function module and check with interviewee on which one he/she wanted.
2.  Need: 明白你的系统要承受多大的压力
    1.  Ask for DAU/MAU (daily active user)
    2.  Predict peak concurrent user; Read QPS, Write QPS (QPS: query per second)
        1.  DAU --> DAU * average query per user / second per day = average query per second.
        2.  Peak query per second = num * average query per second
        3.  Based on application type to define the write/read peak QPS
        4.  Start on next step. 
        5.  注意的是，整个的计算不需要精确，只要大概就好
3.  Application: 将你的系统分解为更小的系统，然后再处理，类似recursive的方法
    1.  merge similar function to service module base on data type.
     (user info, text, relationship, media)
4.  Kilobyte: Data storage: 数据如何存储与访问
    1. Storage: (database 是 file system 的一层封装)
        1.  SQL: 关系型: 适合安全性要求高的(SQL更成熟)：例如 user table
        2.  NoSQL: 非关系型: 例如Social Graph等
        3.  直接存储 File system: 适合于文件型的内容，例如图片，视频等
    2.  为每个application选择一个存储结构，使用schema来细化表的结构
5.  Evolve: 面对面试官提出的特定的情况，需要怎么提高？
    1.  Optimization the system: 解决一些设计上的缺陷，增加更多的feature，处理一些特殊的用例
    2.  Maintenance: Robust, Scalability
6.  Step 1 到 Step 2 是在理解问题；Step 3 - 4 是在找到一个可行的解决方法；Step 5是优化



### 社交软件的 News Feed 的功能 Push 与 Pull
1.  Push: 相当于用户写的时候直接在所有的follower上写内容，这样用户读会快
    1.  复杂度分析：
        1.  Read: one read
        2.  Write: K time databae write
    2.  优点是在更新了之后，follower的 news feed的update是异步进行的，故而无需用户等待update的完成
    3.  缺点是对于明星用户的处理，这种用户的 follower 太多造成说 push的时间非常久且流量非常大
    4.  优化：
        1.  不活跃用户的push和活跃用户的push的优先级是一样的 ==> Rank followers by weight
        2.  普通用户使用push，明星用户使用pull模型
            1.  但是明星用户和普通用户的boundary很难确定，更重要的是有摇摆问题。当明星用户掉为普通用户时，由push变成了pull，会造成数据丢失。
            例如明星用户发帖，然后不会push,此时如果很多人取关造成其变成普通用户，用户又不去进行pull。
2.  Pull: 当用于看 News Feed 的时候，获取所有用户的前 100 条内容，然后合并他们并取前100个内容。
    1.  Merge K sorted Array 
    2.  复杂度分析：
        1.  Read: K time database read and result in user news feed request long.
        2.  Write: 1 time database write.
    3.  系统复杂度分析： write/read query on database for your design.
        1.  Disk read vs memory read: 1000 vs 1 in time.
        2.  算法的计算其实不算问题，因为当我们merge M sorted array的时候其实所有的数据已经在memory里面了；
        故而关键在于读取数据库的问题，数据库很可能不在本地（在数据中心），这样每次query 要经由网络，之后再access
        hard disk, 也就是说要 disk read + internet latency. 所以就是非常的慢。
        3.  主要的问题就是在产生新的100条内容的时候需要等，需要读 M * 100 个 data 于 M 个 server上，而在等的过程
        中用户并没有办法看到内容
    4.  优化：
        1.  针对读取的时候要读 K 个DB造成读取慢，所以可以在dB前加上cache来储存每个用户的最近的100条信息，将K次的dB 读变成 K次的cache读
        2.  Cache每个用户上次的news feed, 这样有个时间点，在每个dB上不需要得到最近的100个，而是最近的超过 cache's latest time的N 个
3.  Pull与Push的选择：
    1.  Push:
        1.  消耗资源少；代码少；实时性要求不高；用户发帖量比较少；双向好友关系 (朋友圈)
    2.  Pull:
        1.  实时性要求高，用户发帖多；单向好友关系造成的明星用户（微博）

### 社交软件的聊天系统：
1.  SNACK:
    1.  Scenario: 用户注册、通讯录、互相发消息，群聊，在线的status，多机登录，历史消息:
        1.  User system:
        2.  Real time service
        3.  online status
    2.  Needs:
        1.  DAU: 100M DAU
        2.  QPS: 
            1.  100M daily --> 100M/(24 * 60 * 60) = 86400 --> 20 message per user = 20K
            2.  Peak QPS: 20K * 5 = 100K
        3.  Storage:
            1.  20 message per user per day: --> 30G per day
    3.  Application:
        1.  User service: SQL: security的要求更高; One to one; Password, email and etc.
            1.  Scenario: 注册，登录，查询其他用户，用户信息修改
            2.  Needs: 
                1.  DAU: 100M
                2.  Read QPS > write QPS
                3.  Write QPS: 0.1 * DAU / time = 100
                4.  Peak write: 300
                4.  Read QPS: 100 * DAU / time = 100k.
                5.  Peak read: 300k
            3.  Application: 
                1.  AuthService: 登录与注册:
                    1.  保持登录状态：使用 session table 来记录用户的session是否expired
                        1.  Session key + session expired: 这样能够记录是否需要用户重新登录。用户的浏览器会发送session key.
                2.  User service: 查询、修改与储存
        2.  Friendship service: one to many relationship. NoSQL (document database):
            1.  Scenario:
                1.  单向好友关系：微博: table record: from_user_id, to_user_id
                2.  双向好友关系：微信:
                    1.  存两条信息，
                    2.  存一条信息，查的时候查两次
                
        3.  Message service: 
            1.  Message table: NoSQL: write heavy
                1.  Scenario:
                    1.  Sent message:
                    2.  Receive message: 
                2.  Needs:
                    1.  DAU: 100 M
                    2.  Read QPS = write QPS = 100 M * 20 (20 message per user) / time = 20K
                    3.  Peak QPS = average QPS * 5 = 100K
                3.  Application:
                    1.  Message service: 
                    2.  Real time service:
                4.  Kilobyte: 
                    1.  Message table: 数据量大，不需要修改，一个message就是一个log. 并且要求写非常快 --> NoSQL
                    2.  Thread table: 需要支持query,并且要支持 secondary index, --> SQL
                        1.  Thread table 就是说记录下来我和人聊天的order，例如我的微信的主页上聊天记录排序是按照聊天时间来排序的
                        2.  OwerID, threadID, Updated time.
            2.  Thread table: history of message: SQL: read heavy
            
        4.  Status service: No SQL
        

### SQL 与 NoSQL的选择
1.  类型：
    1.  MySQL/PosgreSQL: 约 1 K QPS级别的轻量SQL操作
    2.  MongoDB/Cassandra 等硬盘型的 NoSQL数据库的性能：约10K QPS
    3.  Memcached/Redis 等内存型的 NoSQL数据库：约 100k - 1m QPS.
2.  选择标准：
    1.  QPS 低与 QPS 高并不是 SQL 与NoSQL的主要选择标准之一，但是NoSQL的性能更好，NoSQL快10倍左右
    2.  如果需要transaction，一定不能选 NoSQL. NoSQL 不支持transaction.
        1.  NoSQL 不支持 write ahead of log. 
        2.  大概的意思就是我们在金融上如果需要转账，那么A -= 10; B += 10; 如果在A减掉了10之后产生了crash，
        也就造成了B+= 10没有被log, 而此时就需要回滚将 A-= 10的操作给恢复；如果此时是 write after log的话，
        那么可能产生的是在log中crash，此时没有回滚所需要的log。故而就不能完成；如果log在前的话，完成了transaction
        的时候就一定完成了log, 如果log后产生crash，操作并未产生不用修改。
    3.  SQL帮助用户完成了很多事情(Serialization, Muti-index)，所以如果着急发布，应该用SQL. 而且SQL的代码量比较小，
    大概是NoSQL的一半左右。
    4.  Scale ability: NoSQL的scale ability的承受更好
    5.  有没有 multi-index/ secondary index. 有的话就用 SQL
    6.  SQL 在sharding上要自己做，但是second index就不需要自己做。所以NoSQL不需要管 scale的事情，而SQL不要管multi-index的事情
    
### Cache: 缓存
1.  常用软件: Memcached: 只缓存不储存；Redis: 既缓存又储存
2.  Cache不一定存在于内存中，硬盘上也可以。例如将远处的服务器上的文件存到当前server上的硬盘上来减少网络延迟的影响
3.  Memcached: 一款帮助你Cache在内存中的软件
    1.  LRU, LSU 
4.  凡是读多写少的服务就尽可能的使用 Cache:
    1.  在写的时候先删除掉cache中的key, 然后再去 database 修改；之后再读的时候要去 dB中读取来防止 inconsistent.
    2.  如果直接在cache中修改，那么如果database write写失败的话，那么就产生了 data mismatch 了
5.  Cache 能够挡住 99.5% 以上的 load, 只有 0.05 %的内容需要 dB 来处理。
6.  MemCached: 读非常的快；Reids: 读写都非常快，但是读没有Memcached.

### Other Note:
1.  一般来说 MySQL 上能处理小于1,000的QPS; NoSQL 上能处理小于 10,000的QPS.
2.  Peak QPS / average QPS < 10 most of time, should consider it equal to 3 - 7 around 5.
5.  用户系统，例如处理用户的注册信息的系统，他们往往是读多写少的系统（用户看另一个用户多，注册新用户或者改信息的少）
在这个系统中，一定要用Cache 进行优化。
6.  system 的改动要尽可能的不做大改
7.  两台数据库不能做join，但是join操作本身就不该处理。
8.  Cassandra:
    1.  三层NoSQL的数据库
    2.  rowkey (hash key), columnkey (timestamp + user ID), value
    3.  columnKey used to support tree map to support range query. 上周到这周的关注的好友的表
    4.  value 是一个string，可以自己serization 和 deseterization
9.  某些关键词：
    1.  load balancer, Memcache, NodeJS, MongoDB, MySQL, Sharding, Consistent hashing, Master Slave, 
    HDFS, handoop. 